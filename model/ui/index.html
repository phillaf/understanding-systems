<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Economic Signal Graph</title>
  <link rel="icon" href="data:,">
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: #0f172a;
      color: #f8fafc;
      height: 100vh;
      overflow: hidden;
    }

    /* Main layout */
    .app {
      display: flex;
      flex-direction: column;
      height: 100vh;
    }

    header {
      background: #1e293b;
      border-bottom: 1px solid #334155;
      padding: 0.4rem 1rem;
      display: flex;
      align-items: center;
      justify-content: space-between;
      flex-shrink: 0;
    }

    header h1 { font-size: 0.9rem; font-weight: 600; }

    .header-stats {
      display: flex;
      gap: 1.5rem;
      font-size: 0.7rem;
    }

    .header-stat {
      display: flex;
      align-items: center;
      gap: 0.4rem;
    }

    .header-stat .label { color: #64748b; }
    .header-stat .value { font-weight: 600; font-family: monospace; }
    .header-stat .value.good { color: #22c55e; }
    .header-stat .value.medium { color: #eab308; }
    .header-stat .value.poor { color: #ef4444; }

    /* Main content area */
    .main-content {
      flex: 1;
      display: flex;
      position: relative;
      overflow: hidden;
    }

    /* Circuit takes full space */
    #circuit-container {
      flex: 1;
      background: #0f172a;
    }

    /* Floating edge editor overlay */
    #edge-overlay {
      position: absolute;
      bottom: 1rem;
      left: 1rem;
      width: 300px;
      background: #1e293b;
      border: 1px solid #334155;
      border-radius: 8px;
      box-shadow: 0 10px 40px rgba(0,0,0,0.5);
      display: none;
      z-index: 100;
    }

    #edge-overlay.visible { display: block; }

    .overlay-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0.6rem 0.75rem;
      border-bottom: 1px solid #334155;
    }

    .overlay-header h3 {
      font-size: 0.75rem;
      font-weight: 600;
      color: #94a3b8;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .close-btn {
      background: none;
      border: none;
      color: #64748b;
      cursor: pointer;
      font-size: 1.2rem;
      line-height: 1;
      padding: 0.2rem;
    }

    .close-btn:hover { color: #f8fafc; }

    .overlay-body { padding: 0.75rem; }

    /* Edge path display */
    .edge-path {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      padding: 0.5rem;
      background: #0f172a;
      border-radius: 4px;
      font-size: 0.7rem;
      margin-bottom: 0.75rem;
    }

    .edge-path .node {
      padding: 0.2rem 0.4rem;
      border-radius: 3px;
      font-weight: 500;
    }

    .edge-path .node.from {
      background: rgba(59, 130, 246, 0.2);
      color: #3b82f6;
    }

    .edge-path .node.to {
      background: rgba(34, 197, 94, 0.2);
      color: #22c55e;
    }

    .edge-path .arrow { color: #64748b; }

    /* Form controls */
    .form-group {
      margin-bottom: 0.6rem;
    }

    .form-group label {
      display: block;
      font-size: 0.65rem;
      color: #94a3b8;
      margin-bottom: 0.2rem;
    }

    .form-group input, .form-group select {
      width: 100%;
      background: #0f172a;
      border: 1px solid #475569;
      border-radius: 4px;
      padding: 0.35rem 0.5rem;
      color: #f8fafc;
      font-size: 0.75rem;
    }

    .form-group input:focus, .form-group select:focus {
      outline: none;
      border-color: #3b82f6;
    }

    .form-row {
      display: flex;
      gap: 0.5rem;
    }

    .form-row .form-group { flex: 1; margin-bottom: 0; }

    #transform-preview {
      width: 100%;
      height: 80px;
      background: #0f172a;
      border-radius: 4px;
      margin-top: 0.5rem;
    }

    /* Charts pane - collapsible side panel */
    #charts-pane {
      position: absolute;
      top: 0;
      right: 0;
      height: 100%;
      background: #1e293b;
      border-left: 1px solid #334155;
      display: flex;
      flex-direction: column;
      z-index: 50;
      transition: transform 0.2s ease;
    }

    #charts-pane.collapsed {
      transform: translateX(calc(100% - 32px));
    }

    #charts-pane.collapsed .pane-content { opacity: 0; pointer-events: none; }
    #charts-pane.collapsed .pane-toggle { transform: rotate(180deg); }

    .pane-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0.5rem 0.75rem;
      border-bottom: 1px solid #334155;
      background: #1e293b;
    }

    .pane-header h3 {
      font-size: 0.7rem;
      font-weight: 600;
      color: #94a3b8;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .pane-toggle {
      background: none;
      border: none;
      color: #64748b;
      cursor: pointer;
      font-size: 1rem;
      padding: 0.2rem;
      transition: transform 0.2s ease;
    }

    .pane-toggle:hover { color: #f8fafc; }

    .pane-content {
      flex: 1;
      overflow-y: auto;
      padding: 0.5rem;
      transition: opacity 0.15s ease;
    }

    /* Resize handle */
    .resize-handle {
      position: absolute;
      top: 0;
      left: 0;
      width: 5px;
      height: 100%;
      cursor: ew-resize;
      background: transparent;
    }

    .resize-handle:hover,
    .resize-handle.dragging {
      background: #3b82f6;
    }

    /* Empty state */
    .empty-state {
      text-align: center;
      padding: 2rem 1rem;
      color: #64748b;
      font-size: 0.75rem;
    }

    .empty-state .icon {
      font-size: 2rem;
      margin-bottom: 0.5rem;
      opacity: 0.5;
    }

    /* Chart cards */
    .chart-card {
      background: #0f172a;
      border-radius: 6px;
      margin-bottom: 0.5rem;
      overflow: hidden;
    }

    .chart-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0.4rem 0.6rem;
      background: rgba(0,0,0,0.3);
    }

    .chart-header h4 {
      font-size: 0.7rem;
      font-weight: 500;
      display: flex;
      align-items: center;
      gap: 0.4rem;
    }

    .chart-header .badge {
      font-size: 0.55rem;
      padding: 0.1rem 0.3rem;
      border-radius: 3px;
      font-weight: 500;
    }

    .chart-header .badge.input {
      background: rgba(59, 130, 246, 0.2);
      color: #3b82f6;
    }

    .chart-header .badge.computed {
      background: rgba(34, 197, 94, 0.2);
      color: #22c55e;
    }

    .chart-header .badge.fitted {
      background: rgba(251, 191, 36, 0.2);
      color: #fbbf24;
    }

    .chart-header .close-btn {
      font-size: 1rem;
      padding: 0;
    }

    .chart-metrics {
      display: flex;
      gap: 0.75rem;
      padding: 0.3rem 0.6rem;
      font-size: 0.6rem;
      background: rgba(0,0,0,0.3);
      border-bottom: 1px solid #334155;
    }

    .chart-metrics .metric {
      display: flex;
      align-items: center;
      gap: 0.25rem;
    }

    .chart-metrics .metric-label {
      color: #64748b;
    }

    .chart-metrics .metric-value {
      font-family: monospace;
      font-weight: 600;
      color: #f8fafc;
    }

    .chart-metrics .metric-value.good { color: #22c55e; }
    .chart-metrics .metric-value.medium { color: #eab308; }
    .chart-metrics .metric-value.poor { color: #ef4444; }

    .chart-canvas {
      width: 100%;
      height: 100px;
    }

    .chart-legend {
      display: flex;
      gap: 0.75rem;
      padding: 0.3rem 0.6rem;
      font-size: 0.6rem;
      color: #94a3b8;
      background: rgba(0,0,0,0.2);
    }

    .legend-item {
      display: flex;
      align-items: center;
      gap: 0.2rem;
    }

    .legend-dot {
      width: 6px;
      height: 6px;
      border-radius: 50%;
    }

    /* Instructions tooltip */
    .instructions {
      position: absolute;
      bottom: 1rem;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(30, 41, 59, 0.95);
      border: 1px solid #334155;
      border-radius: 6px;
      padding: 0.5rem 1rem;
      font-size: 0.7rem;
      color: #94a3b8;
      z-index: 10;
      pointer-events: none;
      opacity: 0.9;
    }

    .instructions strong { color: #3b82f6; }
    .instructions span { margin: 0 0.5rem; color: #475569; }
  </style>
</head>
<body>
  <div class="app">
    <header>
      <h1>Economic Signal Graph</h1>
      <div class="header-stats">
        <div class="header-stat">
          <span class="label">Signals:</span>
          <span class="value" id="signal-count">4</span>
        </div>
        <div class="header-stat">
          <span class="label">Edges:</span>
          <span class="value" id="edge-count">3</span>
        </div>
        <div class="header-stat">
          <span class="label">Loss:</span>
          <span class="value" id="loss-value">â€”</span>
        </div>
        <div class="header-stat">
          <span class="label">Fitted:</span>
          <span class="value" id="fitted-count">0/0</span>
        </div>
      </div>
    </header>

    <div class="main-content">
      <!-- Full-screen circuit -->
      <div id="circuit-container"></div>

      <!-- Collapsible charts pane -->
      <div id="charts-pane" style="width: 350px;">
        <div class="pane-header">
          <button class="pane-toggle" id="pane-toggle" title="Toggle panel">â–¶</button>
          <h3>Signal Charts</h3>
        </div>
        <div class="pane-content" id="charts-content">
          <div class="empty-state">
            <div class="icon">ðŸ“Š</div>
            <div>Click nodes in the graph<br>to view their time series</div>
          </div>
        </div>
        <div class="resize-handle" id="resize-handle"></div>
      </div>

      <!-- Floating edge editor -->
      <div id="edge-overlay">
        <div class="overlay-header">
          <h3>Edit Edge</h3>
          <button class="close-btn" id="close-edge-overlay">Ã—</button>
        </div>
        <div class="overlay-body" id="edge-editor-body">
          <!-- Populated dynamically -->
        </div>
      </div>

      <!-- Instructions -->
      <div class="instructions">
        <strong>Click nodes</strong> to view charts
        <span>|</span>
        <strong>Click edges</strong> to edit parameters
      </div>
    </div>
  </div>

  <script type="module">
    import { Signal, Edge, Graph, transforms, ModelFit } from '/kernel/index.js';
    import { CircuitView } from '/ui/circuit-view.js';

    // ============================================
    // TEST DATA: 2018-2020 (monthly)
    // ============================================
    
    const testData = {
      fed_rate: [
        1.42, 1.42, 1.51, 1.69, 1.70, 1.82, 1.91, 1.91, 1.95, 2.19, 2.20, 2.27,
        2.40, 2.40, 2.41, 2.42, 2.39, 2.38, 2.40, 2.13, 2.04, 1.83, 1.55, 1.55,
        1.55, 1.58, 0.65, 0.05, 0.05, 0.08, 0.09, 0.10, 0.09, 0.09, 0.09, 0.09, 0.09
      ],
      credit_spread: [
        0.57, 0.60, 0.58, 0.54, 0.56, 0.56, 0.54, 0.52, 0.52, 0.61, 0.69, 0.74,
        0.67, 0.59, 0.57, 0.55, 0.59, 0.62, 0.56, 0.58, 0.60, 0.55, 0.52, 0.53,
        0.56, 0.63, 1.08, 2.25, 1.73, 1.37, 1.21, 1.12, 1.05, 1.00, 0.93, 0.87, 0.78
      ],
      actual_recession: [
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0
      ]
    };

    function tToDate(t) {
      const year = 2018 + Math.floor(t / 12);
      const month = t % 12;
      const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
      return `${months[month]} '${String(year).slice(2)}`;
    }

    // ============================================
    // BUILD THE MODEL
    // ============================================
    
    const graph = new Graph();

    graph.addSignal(new Signal({ name: 'fed_rate', observed: true, description: 'Federal Funds Rate', unit: '%' }));
    graph.addSignal(new Signal({ name: 'credit_spread', observed: true, description: 'BAA-AAA Spread', unit: '%' }));
    graph.addSignal(new Signal({ name: 'financial_stress', observed: false, description: 'Combined stress index' }));
    graph.addSignal(new Signal({ name: 'recession_probability', observed: false, description: 'Model recession probability', min: 0, max: 1 }));

    graph.addEdge(new Edge({ from: 'fed_rate', to: 'financial_stress', weight: 0.15, transform: 'linear', delay: 3 }));
    graph.addEdge(new Edge({ from: 'credit_spread', to: 'financial_stress', weight: 0.4, transform: 'linear', delay: 0 }));
    graph.addEdge(new Edge({ from: 'financial_stress', to: 'recession_probability', weight: 2.5, transform: 'sigmoid', delay: 6 }));

    // Inject observed data
    testData.fed_rate.forEach((v, t) => graph.getSignal('fed_rate').setValue(t, v));
    testData.credit_spread.forEach((v, t) => graph.getSignal('credit_spread').setValue(t, v));

    // Set ground truth for recession_probability
    const recessionSignal = graph.getSignal('recession_probability');
    recessionSignal.setGroundTruth(
      testData.actual_recession.map((value, t) => ({ t, value }))
    );

    // Create ModelFit instance
    const modelFit = new ModelFit(graph, {
      recession_probability: 1.0  // Weight for loss function
    });

    function runSimulation() {
      for (const [name, signal] of graph.signals) {
        if (!signal.observed) signal.history.clear();
      }
      for (let t = 0; t <= 36; t++) {
        graph.step(t);
      }
    }

    runSimulation();

    // Update header stats
    document.getElementById('signal-count').textContent = graph.signals.size;
    document.getElementById('edge-count').textContent = graph.edges.length;

    // ============================================
    // MODEL FIT DISPLAY
    // ============================================

    function updateFitDisplay() {
      const summary = modelFit.getSummary();
      
      // Update header
      const lossEl = document.getElementById('loss-value');
      const loss = summary.globalLoss;
      lossEl.textContent = isFinite(loss) ? loss.toFixed(3) : 'â€”';
      
      lossEl.classList.remove('good', 'medium', 'poor');
      if (loss < 0.2) lossEl.classList.add('good');
      else if (loss < 0.5) lossEl.classList.add('medium');
      else lossEl.classList.add('poor');
      
      document.getElementById('fitted-count').textContent = 
        `${summary.signalsFitted}/${summary.signalsWithGroundTruth}`;
    }

    // ============================================
    // CHART RENDERING
    // ============================================

    const visibleCharts = new Set();

    function drawChart(canvas, signalName, signal) {
      const ctx = canvas.getContext('2d');
      const rect = canvas.getBoundingClientRect();
      const width = canvas.width = rect.width * 2;
      const height = canvas.height = rect.height * 2;
      
      ctx.fillStyle = '#0f172a';
      ctx.fillRect(0, 0, width, height);

      const history = signal.getHistoryArray();
      const data = history.map(h => h.value);
      if (data.length === 0) return;

      const padding = { top: 12, right: 12, bottom: 20, left: 40 };
      const chartWidth = width - padding.left - padding.right;
      const chartHeight = height - padding.top - padding.bottom;

      let min = Math.min(...data);
      let max = Math.max(...data);
      
      // Include ground truth in range calculation if present
      if (signal.hasGroundTruth()) {
        const gtValues = signal.getGroundTruthArray().map(h => h.value);
        min = Math.min(min, ...gtValues);
        max = Math.max(max, ...gtValues);
      }
      
      const range = max - min || 1;
      const yMin = min - range * 0.05;
      const yMax = max + range * 0.05;
      const yRange = yMax - yMin;

      // Grid lines
      ctx.strokeStyle = '#334155';
      ctx.lineWidth = 1;
      ctx.setLineDash([3, 3]);
      for (let i = 0; i <= 2; i++) {
        const y = padding.top + (i / 2) * chartHeight;
        ctx.beginPath();
        ctx.moveTo(padding.left, y);
        ctx.lineTo(width - padding.right, y);
        ctx.stroke();
      }
      ctx.setLineDash([]);

      // Y axis labels
      ctx.fillStyle = '#64748b';
      ctx.font = '16px monospace';
      ctx.textAlign = 'right';
      for (let i = 0; i <= 2; i++) {
        const y = padding.top + (i / 2) * chartHeight;
        const value = yMax - (i / 2) * yRange;
        ctx.fillText(value.toFixed(2), padding.left - 5, y + 5);
      }

      // X axis labels
      ctx.textAlign = 'center';
      [0, 18, 36].forEach(t => {
        const x = padding.left + (t / 36) * chartWidth;
        ctx.fillText(tToDate(t), x, height - 3);
      });

      // Ground truth shading and line (for any signal with ground truth)
      if (signal.hasGroundTruth()) {
        const gtArray = signal.getGroundTruthArray();
        
        // Shading for binary ground truth (like recession)
        ctx.fillStyle = 'rgba(239, 68, 68, 0.15)';
        for (const { t, value } of gtArray) {
          if (value >= 0.5) {  // Treat as "on" for binary signals
            const x = padding.left + (t / 36) * chartWidth;
            const barWidth = chartWidth / 36 + 1;
            ctx.fillRect(x, padding.top, barWidth, chartHeight);
          }
        }

        // Ground truth line
        ctx.beginPath();
        ctx.strokeStyle = '#ef4444';
        ctx.lineWidth = 2;
        ctx.setLineDash([5, 3]);
        gtArray.forEach(({ t, value }, i) => {
          const x = padding.left + (t / 36) * chartWidth;
          const y = padding.top + ((yMax - value) / yRange) * chartHeight;
          if (i === 0) ctx.moveTo(x, y);
          else ctx.lineTo(x, y);
        });
        ctx.stroke();
        ctx.setLineDash([]);
      }

      // Main line (computed or observed)
      const color = signal.observed ? '#3b82f6' : '#22c55e';
      ctx.beginPath();
      ctx.strokeStyle = color;
      ctx.lineWidth = 2.5;

      data.forEach((value, i) => {
        const x = padding.left + (i / (data.length - 1)) * chartWidth;
        const y = padding.top + ((yMax - value) / yRange) * chartHeight;
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      });
      ctx.stroke();
    }

    function getSignalMetrics(signal) {
      const metrics = modelFit.calculateAllMetrics();
      return metrics.get(signal.name);
    }

    function renderVisibleCharts() {
      const container = document.getElementById('charts-content');
      
      if (visibleCharts.size === 0) {
        container.innerHTML = `
          <div class="empty-state">
            <div class="icon">ðŸ“Š</div>
            <div>Click nodes in the graph<br>to view their time series</div>
          </div>
        `;
        return;
      }

      container.innerHTML = '';

      for (const name of visibleCharts) {
        const signal = graph.getSignal(name);
        if (!signal) continue;

        const hasGT = signal.hasGroundTruth();
        const metrics = hasGT ? getSignalMetrics(signal) : null;
        
        // Build metrics display
        let metricsHtml = '';
        if (metrics && metrics.hasData) {
          const corrClass = metrics.correlation >= 0.8 ? 'good' : metrics.correlation >= 0.5 ? 'medium' : 'poor';
          metricsHtml = `
            <div class="chart-metrics">
              <span class="metric">
                <span class="metric-label">r</span>
                <span class="metric-value ${corrClass}">${metrics.correlation.toFixed(2)}</span>
              </span>
              <span class="metric">
                <span class="metric-label">RMSE</span>
                <span class="metric-value">${metrics.rmse.toFixed(3)}</span>
              </span>
              ${metrics.bestLag !== 0 ? `
                <span class="metric">
                  <span class="metric-label">lag</span>
                  <span class="metric-value">${metrics.bestLag > 0 ? '+' : ''}${metrics.bestLag}mo</span>
                </span>
              ` : ''}
            </div>
          `;
        }
        
        const card = document.createElement('div');
        card.className = 'chart-card';
        card.dataset.signal = name;
        card.innerHTML = `
          <div class="chart-header">
            <h4>
              ${name.replace(/_/g, ' ')}
              <span class="badge ${signal.observed ? 'input' : 'computed'}">${signal.observed ? 'INPUT' : 'COMPUTED'}</span>
              ${hasGT ? '<span class="badge fitted">FITTED</span>' : ''}
            </h4>
            <button class="close-btn" data-close="${name}">Ã—</button>
          </div>
          ${metricsHtml}
          <canvas class="chart-canvas"></canvas>
          ${hasGT ? `
            <div class="chart-legend">
              <div class="legend-item">
                <span class="legend-dot" style="background: #22c55e;"></span>
                <span>Model</span>
              </div>
              <div class="legend-item">
                <span class="legend-dot" style="background: #ef4444;"></span>
                <span>Ground Truth</span>
              </div>
            </div>
          ` : ''}
        `;
        container.appendChild(card);

        const canvas = card.querySelector('canvas');
        requestAnimationFrame(() => drawChart(canvas, name, signal));

        card.querySelector(`[data-close="${name}"]`).addEventListener('click', () => {
          visibleCharts.delete(name);
          renderVisibleCharts();
        });
      }
    }

    function refreshCharts() {
      for (const name of visibleCharts) {
        const card = document.querySelector(`.chart-card[data-signal="${name}"]`);
        if (!card) continue;
        const canvas = card.querySelector('canvas');
        const signal = graph.getSignal(name);
        if (canvas && signal) {
          drawChart(canvas, name, signal);
        }
      }
    }

    // ============================================
    // EDGE EDITOR
    // ============================================

    let currentEdgeIndex = null;

    function drawTransformPreview(canvas, transformName, weight) {
      const ctx = canvas.getContext('2d');
      const rect = canvas.getBoundingClientRect();
      const width = canvas.width = rect.width * 2;
      const height = canvas.height = rect.height * 2;
      
      ctx.fillStyle = '#0f172a';
      ctx.fillRect(0, 0, width, height);

      const padding = 15;
      const plotWidth = width - 2 * padding;
      const plotHeight = height - 2 * padding;

      // Axes
      ctx.strokeStyle = '#475569';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(padding, height / 2);
      ctx.lineTo(width - padding, height / 2);
      ctx.moveTo(width / 2, padding);
      ctx.lineTo(width / 2, height - padding);
      ctx.stroke();

      const fn = transforms[transformName] || transforms.linear;

      ctx.beginPath();
      ctx.strokeStyle = '#fbbf24';
      ctx.lineWidth = 2.5;

      const xRange = [-3, 3];
      const steps = 80;
      
      for (let i = 0; i <= steps; i++) {
        const inputX = xRange[0] + (i / steps) * (xRange[1] - xRange[0]);
        let outputY = fn(inputX) * weight;
        outputY = Math.max(-2, Math.min(2, outputY));
        
        const screenX = padding + ((inputX - xRange[0]) / (xRange[1] - xRange[0])) * plotWidth;
        const screenY = height / 2 - (outputY / 2) * (plotHeight / 2);
        
        if (i === 0) ctx.moveTo(screenX, screenY);
        else ctx.lineTo(screenX, screenY);
      }
      ctx.stroke();

      ctx.fillStyle = '#64748b';
      ctx.font = '12px monospace';
      ctx.textAlign = 'left';
      ctx.fillText(`y = ${weight.toFixed(2)} Ã— ${transformName}(x)`, padding, height - 4);
    }

    function showEdgeEditor(index, edge) {
      currentEdgeIndex = index;
      const overlay = document.getElementById('edge-overlay');
      const body = document.getElementById('edge-editor-body');

      body.innerHTML = `
        <div class="edge-path">
          <span class="node from">${edge.from.replace(/_/g, ' ')}</span>
          <span class="arrow">â†’</span>
          <span class="node to">${edge.to.replace(/_/g, ' ')}</span>
        </div>
        
        <div class="form-group">
          <label>Weight</label>
          <input type="range" id="edge-weight-slider" min="-3" max="3" step="0.05" value="${edge.weight}">
          <input type="number" id="edge-weight" value="${edge.weight}" step="0.05" style="margin-top: 0.25rem;">
        </div>
        
        <div class="form-row">
          <div class="form-group">
            <label>Transform</label>
            <select id="edge-transform">
              <option value="linear" ${edge.transformName === 'linear' ? 'selected' : ''}>linear</option>
              <option value="sigmoid" ${edge.transformName === 'sigmoid' ? 'selected' : ''}>sigmoid</option>
              <option value="tanh" ${edge.transformName === 'tanh' ? 'selected' : ''}>tanh</option>
              <option value="relu" ${edge.transformName === 'relu' ? 'selected' : ''}>relu</option>
            </select>
          </div>
          
          <div class="form-group">
            <label>Delay (mo)</label>
            <input type="number" id="edge-delay" value="${edge.delay}" min="0" max="24" step="1">
          </div>
        </div>

        <canvas id="transform-preview"></canvas>
      `;

      overlay.classList.add('visible');

      const weightSlider = document.getElementById('edge-weight-slider');
      const weightInput = document.getElementById('edge-weight');
      const transformSelect = document.getElementById('edge-transform');
      const delayInput = document.getElementById('edge-delay');
      const previewCanvas = document.getElementById('transform-preview');

      function updateEdge() {
        edge.weight = parseFloat(weightInput.value) || 0;
        edge.delay = parseInt(delayInput.value) || 0;
        
        const newTransform = transformSelect.value;
        edge.transform = transforms[newTransform] || transforms.linear;
        edge.transformName = newTransform;

        weightSlider.value = edge.weight;

        runSimulation();
        view.update();
        refreshCharts();
        renderVisibleCharts();  // Re-render to update metrics
        updateFitDisplay();
        drawTransformPreview(previewCanvas, edge.transformName, edge.weight);
      }

      weightSlider.addEventListener('input', () => {
        weightInput.value = weightSlider.value;
        updateEdge();
      });

      weightInput.addEventListener('input', () => {
        weightSlider.value = weightInput.value;
        updateEdge();
      });

      transformSelect.addEventListener('change', updateEdge);
      delayInput.addEventListener('input', updateEdge);

      requestAnimationFrame(() => {
        drawTransformPreview(previewCanvas, edge.transformName, edge.weight);
      });
    }

    function hideEdgeEditor() {
      document.getElementById('edge-overlay').classList.remove('visible');
      currentEdgeIndex = null;
      view.deselectAll();
    }

    document.getElementById('close-edge-overlay').addEventListener('click', hideEdgeEditor);

    // ============================================
    // PANE TOGGLE & RESIZE
    // ============================================

    const pane = document.getElementById('charts-pane');
    const toggleBtn = document.getElementById('pane-toggle');
    const resizeHandle = document.getElementById('resize-handle');

    toggleBtn.addEventListener('click', () => {
      pane.classList.toggle('collapsed');
    });

    let isResizing = false;
    let startX, startWidth;

    resizeHandle.addEventListener('mousedown', (e) => {
      isResizing = true;
      startX = e.clientX;
      startWidth = pane.offsetWidth;
      resizeHandle.classList.add('dragging');
      document.body.style.cursor = 'ew-resize';
      document.body.style.userSelect = 'none';
    });

    document.addEventListener('mousemove', (e) => {
      if (!isResizing) return;
      const delta = startX - e.clientX;  // Reversed for right-side panel
      const newWidth = Math.max(250, Math.min(600, startWidth + delta));
      pane.style.width = newWidth + 'px';
    });

    document.addEventListener('mouseup', () => {
      if (isResizing) {
        isResizing = false;
        resizeHandle.classList.remove('dragging');
        document.body.style.cursor = '';
        document.body.style.userSelect = '';
        // Redraw charts at new size
        requestAnimationFrame(refreshCharts);
      }
    });

    // ============================================
    // CIRCUIT VIEW
    // ============================================
    
    const container = document.getElementById('circuit-container');
    const view = new CircuitView(container, graph, {
      onNodeSelect: (name, signal) => {
        // Toggle chart visibility
        if (visibleCharts.has(name)) {
          visibleCharts.delete(name);
        } else {
          visibleCharts.add(name);
          // Make sure pane is visible
          pane.classList.remove('collapsed');
        }
        renderVisibleCharts();
      },
      onEdgeSelect: (index, edge) => {
        if (currentEdgeIndex === index) {
          hideEdgeEditor();
        } else {
          showEdgeEditor(index, edge);
        }
      },
      onDeselect: () => {
        // Don't auto-hide, let user click X
      }
    });

    // ============================================
    // INITIAL STATE
    // ============================================
    
    updateFitDisplay();

    // Start with recession_probability visible
    visibleCharts.add('recession_probability');
    renderVisibleCharts();

    console.log('Model loaded:', graph.toJSON());
  </script>
</body>
</html>
